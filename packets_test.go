package protocol

import (
	"bytes"
	"math/rand"
	"reflect"
	"testing"

	"github.com/pkg/errors"
)

var (
	packetCases = []struct {
		bytes  []byte
		value  packet
		length int
		err    error
	}{
		{[]byte{0x01, 0x00}, packet{id: 0x00, data: []byte{}}, 2, nil},
		{[]byte{0x02, 0x00, 0x00}, packet{id: 0x00, data: []byte{0x00}}, 3, nil},
		{[]byte{0x05, 0x04, 0x03, 0x02, 0x01, 0x00}, packet{id: 0x04, data: []byte{0x03, 0x02, 0x01, 0x00}}, 6, nil},
		{[]byte{0x02, 0x80, 0x01}, packet{id: 0x80, data: []byte{}}, 3, nil},
		{[]byte{0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, packet{id: 0x00, data: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}}, 130, nil},
		{[]byte{}, packet{}, 0, errBufTooSmall},     // empty buffer
		{[]byte{0x01}, packet{}, 1, errBufTooSmall}, // incomplete buffer
	}
)

func TestGetPacket(t *testing.T) {
	for _, c := range packetCases {
		p, n, err := getPacket(c.bytes)
		if !reflect.DeepEqual(p, c.value) || n != c.length || errors.Cause(err) != c.err {
			t.Errorf("have: %#v, want: (%#v, %#v, %#v), got: (%#v, %#v, %#v)", c.bytes, c.value, c.length, c.err, p, n, err)
		}
	}
}

func TestPutPacket(t *testing.T) {
	for _, c := range packetCases {
		if c.err != nil {
			continue // skip invalid cases
		}
		buf := make([]byte, c.length)
		n, err := putPacket(buf, c.value)
		if n != c.length || errors.Cause(err) != c.err || bytes.Compare(buf[:n], c.bytes) != 0 {
			t.Errorf("have: %#v, want: (%#v, %#v, %#v), got: (%#v, %#v, %#v)", c.value, c.length, c.err, c.bytes, n, err, buf[:n])
		}
	}
}

const (
	benchmarkMaxPacketID      = 256
	benchmarkMaxPacketDataLen = 512
)

func BenchmarkGetPacket(b *testing.B) {
	rand.Seed(benchmarkSeed)
	data := make([][]byte, benchmarkDatums)
	for i := range data {
		p := packet{
			id:   int32(rand.Intn(benchmarkMaxPacketID)),
			data: make([]byte, rand.Intn(benchmarkMaxPacketDataLen)),
		}
		rand.Read(p.data)

		buf := make([]byte, 2*maxIntBytes+benchmarkMaxPacketDataLen)
		n, err := putPacket(buf, p)
		if err != nil {
			b.Fatalf("failed to create benchmark data: have: %#v, got: (%#v, %#v, %#v)",
				p,
				n, err, buf[:n])
		}

		data[i] = buf[:n]
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		getPacket(data[i%benchmarkDatums])
	}
}

func BenchmarkPutPacket(b *testing.B) {
	rand.Seed(benchmarkSeed)
	data := make([]packet, benchmarkDatums)
	for i := range data {
		p := packet{
			id:   int32(rand.Intn(benchmarkMaxPacketID)),
			data: make([]byte, rand.Intn(benchmarkMaxPacketDataLen)),
		}
		rand.Read(p.data)
		data[i] = p
	}
	buf := make([]byte, 2*maxIntBytes+benchmarkMaxPacketDataLen)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		putPacket(buf, data[i%benchmarkDatums])
	}
}
